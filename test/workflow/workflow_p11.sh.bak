#!/bin/bash

# 并行对接脚本
# 用法: ./run_docking.sh [并发任务数]

# 设置基础路径
REGISTRY_DIR="./registry"
AMBIG_RESTRAINTS_DIR="$REGISTRY_DIR/ambig_restraints"
LOG_DIR="$REGISTRY_DIR/docking_logs"
CFG_PATTERN="docking-antibody-antigen_updated.cfg"

# 设置默认并发任务数
DEFAULT_JOBS=$(( $(nproc) / 2 ))
MAX_JOBS=${1:-$DEFAULT_JOBS}

# 创建日志目录
mkdir -p "$LOG_DIR"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
JOB_LOG="$LOG_DIR/docking_joblog_$TIMESTAMP.txt"
SUMMARY_LOG="$LOG_DIR/docking_summary_$TIMESTAMP.csv"

# 查找所有配置文件
echo "正在搜索配置文件..."
cfg_files=($(find "$AMBIG_RESTRAINTS_DIR" -type f -name "$CFG_PATTERN"))

total_jobs=${#cfg_files[@]}

if [[ $total_jobs -eq 0 ]]; then
    echo "错误: 未找到任何配置文件 ($CFG_PATTERN)" >&2
    exit 1
fi

echo "找到 $total_jobs 个对接任务"
echo "最大并发任务数: $MAX_JOBS"
echo "开始并行对接..."

# 写入CSV表头
echo "cfg_path,status,time,output_dir" > "$SUMMARY_LOG"

# 定义对接函数
run_docking() {
    local cfg_file="$1"
    local log_id=$(basename $(dirname $(dirname "$cfg_file")))
    local log_file="$LOG_DIR/${log_id}_${TIMESTAMP}.log"
    
    # 提取运行目录（从配置文件内容）
    local run_dir=$(awk -F'=' '/^run_dir/ {gsub(/[[:space:]]+/, "", $2); print $2}' "$cfg_file")
    
    echo "启动对接: $cfg_file"
    echo "运行目录: $run_dir"
    echo "日志文件: $log_file"
    
    # 记录开始时间
    local start_time=$(date +%s)
    
    # 运行对接
    haddock3 "$cfg_file" > "$log_file" 2>&1
    
    # 检查状态
    local status=$?
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    
    # 记录结果
    if [[ $status -eq 0 ]]; then
        echo "✅ 成功完成: $cfg_file (用时: ${duration}秒)"
        echo "$cfg_file,success,$duration,$run_dir" >> "$SUMMARY_LOG"
    else
        echo "❌ 对接失败: $cfg_file (状态码: $status, 用时: ${duration}秒)"
        echo "$cfg_file,failed-$status,$duration,$run_dir" >> "$SUMMARY_LOG"
        
        # 提取错误信息
        local error_msg=$(grep -i -m1 -e "error" -e "fail" -e "exception" "$log_file" | head -1)
        echo "   错误信息: ${error_msg:0:120}..."
    fi
    
    return $status
}

# 导出函数用于parallel
export -f run_docking
export TIMESTAMP
export LOG_DIR
export SUMMARY_LOG

# 使用parallel并行运行
parallel --progress --bar --eta -j "$MAX_JOBS" \
    --joblog "$JOB_LOG" \
    --retries 1 \
    --resume-failed \
    --halt soon,fail=10% \
    run_docking ::: "${cfg_files[@]}"

# 生成摘要报告
success_count=$(grep -c "success" "$SUMMARY_LOG")
failed_count=$((total_jobs - success_count))

echo ""
echo "===== 对接摘要 ====="
echo "总任务数: $total_jobs"
echo "成功任务: $success_count"
echo "失败任务: $failed_count"
echo "总用时: $(awk -F',' 'NR>1 {sum+=$3} END {print sum "秒 (" int(sum/60) "分)"}' "$SUMMARY_LOG")"
echo ""
echo "详细日志: $JOB_LOG"
echo "摘要报告: $SUMMARY_LOG"

if [[ $failed_count -gt 0 ]]; then
    echo ""
    echo "失败任务列表:"
    grep "failed" "$SUMMARY_LOG" | cut -d',' -f1
    echo ""
    echo "请检查失败任务的日志文件获取详细信息"
fi

exit 0
